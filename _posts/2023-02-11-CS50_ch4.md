---
title: "[CS50] Chapter 4. 알고리즘"
categories:
    - CS50
tags:
    - CS
    - note
    - course
    - boostcourse
toc: true
toc_label: "[CS50] Chapter 4. 알고리즘"
toc_icon: "sticky-note"
toc_sticky: true
---
*작성중*
최초작성일: 2023-02-11

부스트코스 <모두를 위한 컴퓨터 과학 (CS50 2019)> 강의 수강

# 4. 알고리즘

## 1. 검색 알고리즘

- 주어진 배열 속에서 특정 값을 찾는 방법을 설명할 수 있다.
- 선형 검색, 이진 검색

<br/>

- 배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조
- 컴퓨터는 모든 숫자를 한 번에 파악할 수 없고 배열 속 내용물을 하나씩 볼 수 있다.
- 그래서 배열 속에서 특정 값을 찾는 검색 알고리즘이 필요

### 선형 검색

- 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사

    ```
    0에서 (n-1)까지의 i
        만약 i번째 요소가 50이면
            True를 반환
    50이 없으면
        False 반환
    ```

### 이진 검색

- 만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작해 찾고자 하는 값과 비교.
- 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복

    ```
    남은 배열이 없다면
        False 반환
    만약 가운데 요소가 50이면
        True를 반환
    50이 가운데 요소보다 작으면
        왼쪽 반을 탐색
    50이 가운데 요소보다 크면
        오른쪽 반을 탐색
    ```

<br/>

## 2. 알고리즘 표기법

- 처리하는 데이터가 많아지고 작업이 복잡해질수록 실행 시간이 중요해짐
- 알고리즘의 실행 시간의 상한과 하한을 표기할 수 있다.
- Big O, Big Ω

<br/>

### 실행 시간

*프로그램이나 알고리즘이 동작하는 데 걸리는 시간*
- 몇 초가 걸리는지
- 몇 번의 계산 과정이 필요한지

### Big O 빅 오 표기법

*알고리즘을 수행하는 데 필요한 시간의 상한선*
- O는 'on the order of'의 약자. '~만큼의 정도로 커지는'
- `O(n)`: on the order of n
- 대략적인 추정값을 표기하는 것
- 계수 생략. 차수만 나타냄
- 문제가 충분히 크다면 n의 차수가 같을 때 곱해진 계수는 거의 영향을 주지 못함

<br/>

| Big-O |알고리즘|
|:-----:|:-----:|
|O(n^2)||
|O(nlogn)||
|O(n)|선형 검색|
|O(logn)|이진 검색|
|O(1)| |

<br/>

### Big Ω 빅 오메가 표기법

*최상의 경우. 알고리즘 실행 시간의 하한*
- Big-O의 반대

<br/>

| Big Ω | 알고리즘|
|:-----:|:-----:|
|Ω(n^2)||
|Ω(nlogn)||
|Ω(n)|배열 안에 존재하는 값의 개수 세기|
|Ω(logn)||
|Ω(1)|선형 검색, 이진 검색|

<br/>

> `Omega` 값과 `Big-O` 값 중 어느 것이 좋아야 좋은 알고리즘인가?
>   - `Big-O`
>   - 컴퓨터 과학자가 가장 걱정하는 부분은 최악의 경우에 프로그램이 어떻게 동작할지, 또는 평균적으로 어떻게 동작하는지.

<br/>

## 3. 선형 검색

- 주어진 배열 또는 구조체에서 선형 검색을 할 수 있다.
- 선형 검색, 구조체

### 선형 검색

*원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색*

#### 효율성 & 비효율성

- 선형 검색 알고리즘은 정확하지만 효율적이지 못함.
- 선형 검색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용
- 정렬은 시간이 오래 걸리고 공간을 더 차지하지만, 여러 번 리스트를 검색해야 하거나 매우 큰 리스트를 검색해야 할 경우 시간을 단축할 수 있음.

#### 예시

##### 특정 숫자 찾기

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;   //main 함수 종료
        }
    }
    printf("Not found\n");
    return 1;   //main 함수 종료
}
```

##### 전화번호부에서 특정 이름 찾아 전화번호 출력

```c
#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
    string names[4] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
    string numbers[4] = {"617-555-0100", "617-555-0101", "617-555-0102", "617-555-0103"};
    // 이름과 전화번호의 순서가 반드시 일치할까?

    for (int i = 0; i < 4; i++)
    {
        // if (names[i] == "EMMA") -> 안 됨
        //C에서 '=='는 문자열에 사용 불가. 문자열 속 문자를 하나씩 비교해야.
        if (strcmp(names[i], "EMMA") == 0)  //문자열비교함수. 같으면 0을 반환
        {
            printf("%s\n", numbers[i]);
            return 0;
        }
        printf("Not found\n");
        return 1;
    }
}
```
- 이름과 번호의 인덱스가 일치해야 함.
- 만약 각각 정렬이라도 한다면?

```c
#include <stdio.h>
#include <cs50.h>
#include <string.h>

// 캡슐화

typedef struct      // 새로운 타입을 정의한다.
                    // struct(구조체)는 C에 미리 정의된 키워드
                    // 여러가지 자료형을 담을 수 있음
{
    string name;
    string number;
}
person;     // person이라는 자료형을 만듦


int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617-555-0100";

    people[1].name = "RODRIGO";
    people[1].number = "617-555-0101";

    people[2].name = "BRIAN";
    people[2].number = "617-555-0102";

    people[3].name = "DAVID";
    people[3].number = "617-555-0103";

    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("%s\n", people[i].number);
            return 0;
        }
        printf("Not found\n");
        return 1;
    }
}
```
- 새로운 자료형으로 `구조체(struct)`를 정의해서 이름과 번호를 묶어줌
- 더욱 확장성 있는 전화번호부 검색 프로그램을 만들 수 있다.

<br/>

## 4. 버블 정렬 (Bubble sort)

- 버블 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.

### 버블 정렬

*두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법*
- 간단하고 직관적인 방법
- 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중
- 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수 있음
- n개의 원소에 대해 버블 정렬을 한 번 수행할 때마다 n번째의 원소가 제 자리를 찾음.

```
(n-1)번 반복
    i가 0에서 (n-2)까지
        만약 i번째와 (i+1)번째 요소의 순서가 잘못되었다면
            둘을 바꾼다
```

### 버블 정렬의 실행 시간 상한

- 바깥 반복문 (n - 1)번, 안쪽 반복문 (n - 1)번 반복
    (n - 1) x (n - 1) -> `O(n^2)`

    <br/>

| Big-O |알고리즘|
|:-----:|:-----:|
|O(n^2)|버블 정렬|
|O(nlogn)||
|O(n)|선형 검색|
|O(logn)|이진 검색|
|O(1)| |

- 이진 검색이 선형 검색보다 좋다고 하는 것은 옳지 않다.
- 이진 검색은 정렬하는 과정이 필요하기 때문
- 검색을 여러 번 반복해야 하는 상황이라면 먼저 한 번 정렬해두고 빠른 검색법을 이용하는 게 장기적인 이득을 볼 수 있다.

### 버블 정렬의 실행 시간 하한

- 버블 정렬의 빅오메가는 Ω(n^2)
- 이미 정렬된 입력이 들어왔다 해도 버블 정렬 알고리즘은 여전히 모두 확인하도록 되어 있기 때문에.

<br/>

| Big Ω | 알고리즘|
|:-----:|:-----:|
|Ω(n^2)|버블 정렬|
|Ω(nlogn)||
|Ω(n)||
|Ω(logn)||
|Ω(1)|선형 검색, 이진 검색|

<br/>

## 5. 선택 정렬 (Selection sort)

- 선택 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.

### 선택 정렬

*배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식*
- 교환 횟수는 최소화, 각 자료 비교 횟수는 증가
- 한 번의 교환이 일어나기 위해 정렬되지 않은 모든 수와 비교가 이루어져야 함.

```
i는 0부터 (n-1)까지
    i번째 항목부터 마지막 항목 사이에서 가장 작은 항목을 찾는다.
    가장 작은 항목을 i번째 항목과 바꾼다.
```

### 선택 정렬의 실행 시간 - 빅 오

- n개 항목을 확인. 최솟값 찾아서 옮긴 후 (n-1)개 항목 확인...
    n + (n - 1) + (n - 2) + ... + 1 = n(n - 1)/2 -> `O(n^2)`

| Big-O |알고리즘|
|:-----:|:-----:|
|O(n^2)|버블 정렬, 선택 정렬|
|O(nlogn)||
|O(n)|선형 검색|
|O(logn)|이진 검색|
|O(1)| |

### 선택 정렬의 실행 시간 - 빅오메가

- 정렬되어 있다 해도 그것이 최솟값인지 모르기 때문에 똑같이 확인하는 과정을 거칠 것임.
    `Ω(n^2)`

| Big Ω | 알고리즘|
|:-----:|:-----:|
|Ω(n^2)|버블 정렬, 선택 정렬|
|Ω(nlogn)||
|Ω(n)||
|Ω(logn)||
|Ω(1)|선형 검색, 이진 검색|

<br/>

## 6. 정렬 알고리즘의 실행시간

- 여러 정렬 알고리즘과 검색 알고리즘의 실행 시간을 Big O와 Big Ω로 정의할 수 있다.

### 버블 정렬 개선

```
교환이 없을 때까지 반복
    i가 0에서 (n-2)까지
        만약 i번째와 (i+1)번째 요소의 순서가 잘못되었다면
            둘을 바꾼다
```
- 이미 정렬되어 교환이 일어나지 않으면 반복이 멈추는 조건을 추가.
    -> 최선의 경우 n - 1번이면 됨. -> `Ω(n)`

| Big Ω | 알고리즘|
|:-----:|:-----:|
|Ω(n^2)|선택 정렬|
|Ω(nlogn)||
|Ω(n)|개선된 버블 정렬|
|Ω(logn)||
|Ω(1)|선형 검색, 이진 검색|


## 7. 재귀

## 8. 병합 정렬
